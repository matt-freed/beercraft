package com.beercom.interceptor;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.List;

import javax.decorator.Decorator;
import javax.decorator.Delegate;
import javax.inject.Inject;

import org.apache.commons.beanutils.PropertyUtils;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;

import com.beercom.entity.CustomizableEntity;
import com.beercom.entity.Fermentable;
import com.beercom.entity.FermentableAddition;
import com.beercom.entity.Hop;
import com.beercom.entity.HopAddition;
import com.beercom.entity.MiscIngredient;
import com.beercom.entity.MiscIngredientAddition;
import com.beercom.entity.Recipe;
import com.beercom.entity.Style;
import com.beercom.entity.User;
import com.beercom.entity.Yeast;
import com.beercom.entity.YeastAddition;
import com.beercom.entity.recipe.RecipeBO;
import com.beercom.util.HibernateUtil;

/**
 * Authorized decorator for the RecipeBO
 * checks to ensure that a user is the owner of the recipe
 * they are modifying
 */
@Decorator
public class AuthorizedDecorator implements RecipeBO{
	
	@Inject
	@Delegate
	private RecipeBO recipeBO;
	
	/**
	 * Uses reflection and tail-recursion to get all customizable entity descendants of the root.
	 * This was fun but too complex for our purposes, along with performance concerns 
	 * @param rootEntity
	 * @param entityList
	 * @return
	 */
	@Deprecated
	@SuppressWarnings({ "unchecked", "unused" })
	private List<CustomizableEntity> getRecursiveFlattenedObjectGraph(CustomizableEntity rootEntity, List<CustomizableEntity> entityList){
		entityList.add(rootEntity);
		try {
				//Get all fields for the entity
				Field[] fields = rootEntity.getClass().getDeclaredFields();
			
				for(Field field: fields){
					Class<?> clazz = field.getType();
					
					//If the field is a subclass of customizable entity,
					if(CustomizableEntity.class.isAssignableFrom(clazz)){
						//
						CustomizableEntity childEntity = (CustomizableEntity) PropertyUtils.getProperty(rootEntity, field.getName());
						if(childEntity != null){
							
							//We've got to go deeper!
							if(!entityList.contains(childEntity)){
								getRecursiveFlattenedObjectGraph(childEntity, entityList);
							}
						}
					}
					//If the field is a list of other entities, we need to go through each one
					else if(List.class.isAssignableFrom(clazz)){
						ParameterizedType parmType = (ParameterizedType) field.getGenericType();
						
						Class<?> type = (Class<?>)parmType.getActualTypeArguments()[0];
						
						if(CustomizableEntity.class.isAssignableFrom(type)){
							List<CustomizableEntity> list = (List<CustomizableEntity>) PropertyUtils.getProperty(rootEntity, field.getName());
							
							//recurse through each item in list
							for(CustomizableEntity entityInList: list){
								getRecursiveFlattenedObjectGraph(entityInList, entityList);
							}
						}
					}
				}

		} catch (Exception e){
			throw new RuntimeException("Error flattening the recipe", e);
		}
		
		return entityList;
	}

	/**
	 * Looks at each element in the recipe graph and verifies ownership
	 * 
	 * @param recipe
	 * @param user
	 * @param isDelete
	 */
	private void verifyAuthorizations(Recipe recipe, User user, boolean isDelete){
		List<CustomizableEntity> entityList = getFlattenedRecipeGraph(recipe);
		
		for(CustomizableEntity entity: entityList){
			verifyOwner(entity, user, isDelete);
		}
	}
	
	/**
	 * Looks at the current owner id in the db, compares
	 * it to the current owner id
	 * @param entity
	 * @param user
	 */
	@SuppressWarnings("unchecked")
	private void verifyOwner(CustomizableEntity entity, User user, boolean isDelete){
		if(entity.getId() != null){
			List<String> owner = (List<String>) HibernateUtil.getSessionFactory().getCurrentSession().createCriteria(entity.getClass())
				.add(Restrictions.eq("id", entity.getId()))
				.setProjection(Projections.property("owner")).list();
			
			//If this id doesn't exist in the db, reset it so one will be autogenerated
			if(owner == null || owner.size() == 0){
				entity.setId(null);
			}
			else if(!owner.get(0).equals(user.getAuthId())){
				//TODO: we could throw security exception, but we don't want to give clues that 
				//this id exists. just change it to null so a new one will be generated
				entity.setId(null);
				//TODO: log this
			}
		}
		else if(isDelete){
			throw new SecurityException("Id must not be null to delete");
		}
	}
	
	@Override
	public void saveRecipe(Recipe recipe, User user) {
		verifyAuthorizations(recipe, user, false);

		recipeBO.saveRecipe(recipe, user);
	}
	
	@Override
	public void deleteRecipe(Recipe recipe, User user) {
		verifyAuthorizations(recipe, user, true);
		
		recipeBO.deleteRecipe(recipe, user);
	}
	
	@Override
	public List<Recipe> getAllRecipes() {
		return recipeBO.getAllRecipes();
	}

	@Override
	public List<Recipe> getRecipesForUser(User user) {
		return recipeBO.getRecipesForUser(user);
	}

	@Override
	public Recipe newRecipe() {
		return recipeBO.newRecipe();
	}


	@Override
	public Recipe searchRecipe(Long id) {
		return recipeBO.searchRecipe(id);
	}

	@Override
	public HopAddition newHopAdditionForRecipe(Recipe recipe, Hop hopType) {
		return recipeBO.newHopAdditionForRecipe(recipe, hopType);
	}

	@Override
	public FermentableAddition newFermentableAdditionForRecipe(Recipe recipe,
			Fermentable fermentableType) {
		return recipeBO.newFermentableAdditionForRecipe(recipe, fermentableType);
	}

	@Override
	public YeastAddition newYeastAdditionForRecipe(Recipe recipe,
			Yeast yeastType) {
		return recipeBO.newYeastAdditionForRecipe(recipe, yeastType);
	}

	@Override
	public MiscIngredientAddition newMiscAdditionForRecipe(Recipe recipe,
			MiscIngredient miscType) {
		return recipeBO.newMiscAdditionForRecipe(recipe, miscType);
	}

	@Override
	public void removeHopAddition(Recipe recipe, HopAddition hopAdd) {
		recipeBO.removeHopAddition(recipe, hopAdd);
	}

	@Override
	public void removeFermentableAddition(Recipe recipe,
			FermentableAddition fermentableAdd) {
		recipeBO.removeFermentableAddition(recipe, fermentableAdd);
	}

	@Override
	public void removeYeastAddition(Recipe recipe, YeastAddition yeastAdd) {
		recipeBO.removeYeastAddition(recipe, yeastAdd);
	}

	@Override
	public void removeMiscAddition(Recipe recipe, MiscIngredientAddition miscAdd) {
		recipeBO.removeMiscAddition(recipe, miscAdd);
	}

	@Override
	public List<Style> getAllStyles() {
		return recipeBO.getAllStyles();
	}

	@Override
	public void saveStyle(Style style) {
		recipeBO.saveStyle(style);
	}

	@Override
	public Style newStyle() {
		return recipeBO.newStyle();
	}

	@Override
	public void deleteStyle(Style style) {
		recipeBO.deleteStyle(style);
	}

	@Override
	public Style searchStyle(Long id) {
		return recipeBO.searchStyle(id);
	}

	@Override
	public List<CustomizableEntity> getFlattenedRecipeGraph(Recipe recipe) {
		return recipeBO.getFlattenedRecipeGraph(recipe);
	}

	@Override
	public Recipe copyRecipe(Recipe recipe) {
		return recipeBO.copyRecipe(recipe);
	}

}
